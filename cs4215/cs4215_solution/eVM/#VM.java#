package cs3212.eVM; 

import cs3212.eVML.*;

import java.util.*;

public class VM {

    // run takes an instruction array and executes its
    // instructions from left to right until DONE is reached

   public static Value run(INSTRUCTION[] instructionArray) {
         
      // initialize registers

      int pc = 0;

      Stack <Value> os = new Stack <Value> ();

      // loop

      loop:
      while (true) {
         INSTRUCTION i = instructionArray[pc];

         // System.out.println("pc: "+pc+"; instruction: "+i);

         switch (i.OPCODE) {

	     // pushing integer constants on the operand stack
	     // in form of IntValue instances

            case OPCODES.LDCI: os.push(new 
				       IntValue(Integer.
						parseInt(((LDCI)i).VALUE)));
 			       pc++;
			       break;

	     // pushing boolean constants on the operand stack
	     // in form of BoolValue instances

            case OPCODES.LDCB: os.push(new 
					  BoolValue(((LDCB)i).
						    VALUE.equals("true")));
		               pc++;
			       break;

            // primitive operations: pop arguments from operand stack
	    // and push result back on operand stack

			       // use non-shortcut |
            case OPCODES.OR:   os.push(new 
				       BoolValue(
						 ((BoolValue)os.pop()).value
						 | 
						 ((BoolValue)os.pop()).value
						 ));
			       pc++;
			       break;

            case OPCODES.AND:  os.push(new 
				       BoolValue(((BoolValue)os.pop()).value 
						 & 
						 ((BoolValue)os.pop()).value
						 ));
	   		       pc++;
			       break;

            case OPCODES.NOT:  os.push(new BoolValue(
				    ! ((BoolValue) os.pop()).value));
			       pc++;
			       break;

            case OPCODES.GT:   os.push(new BoolValue(
      				    ((IntValue) os.pop()).value
				    <
      				    ((IntValue) os.pop()).value));
 			       pc++;
			       break;

            case OPCODES.LT:   os.push(new 
				       BoolValue(
						 ((IntValue) os.pop()).value
						 >
						 ((IntValue) os.pop()).value));
 			       pc++;
			       break;

            case OPCODES.EQ:   os.push(new 
				       BoolValue(
						 ((IntValue) os.pop()).value
						 ==
						 ((IntValue) os.pop()).value));
    		               pc++;
			       break;

            case OPCODES.PLUS: os.push(new IntValue(
      				    ((IntValue) os.pop()).value
				    + 
      				    ((IntValue) os.pop()).value));
 			       pc++;
			       break;

            case OPCODES.TIMES:os.push(new IntValue(
      				    ((IntValue) os.pop()).value
				    * 
      				    ((IntValue) os.pop()).value));
 			       pc++;
			       break;

            // watch out, the non-commutative operations have to consider
	    // that the arguments appear on the stack in reverse order!

            case OPCODES.MINUS:os.push(new IntValue(
      				    - ((IntValue) os.pop()).value
				    +
      				    ((IntValue) os.pop()).value));
 			       pc++;
			       break;

            case OPCODES.DIV:  int divisor = ((IntValue) os.pop()).value;
		               os.push(new 
				       IntValue(((IntValue) os.pop()).value
						/
						divisor));
 			       pc++;
			       break;

	    // DONE simply breaks the loop. The result is now
	    // on top of the operand stack

            case OPCODES.DONE: break loop;

            default:           System.out.println(" unknown opcode: " 
                                                  + i.OPCODE);
                               pc++;
        }
     }

      // return what is on top of the operand stack
      return os.pop();
  }
}
